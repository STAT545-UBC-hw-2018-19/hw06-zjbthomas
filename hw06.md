---
title: "STAT 547M Homework 6"
author: "Junbin ZHANG"
date: "Oct 30, 2018"
output:
  html_document:
    keep_md: true
    toc: true
    toc_depth: 2
    theme: readable
---

# Bring rectangular data in

```r
## load gapminder
suppressPackageStartupMessages(library(gapminder))
## load tidyverse
suppressPackageStartupMessages(library(tidyverse))
## load testthat
suppressPackageStartupMessages(library(testthat))
```

# Task 1: Character data

## Exercises 14.2.5

### Question 1

**In code that doesn't use stringr, you'll often see `paste()` and `paste0()`. What's the difference between the two functions?**

The usages of `paste()` and `paste0()` can be obtained by running `?paste` in console, and they are listed as followed.

`paste (..., sep = " ", collapse = NULL)`

`paste0(..., collapse = NULL)`

So the difference is, `paste()` allows us to add an separator between strings we want to concatenate. Let's try to use `paste()` and `paste0()` to show their differences.
  

```r
# make paste() and paste0() have the same outputs
paste("STAT", "547M", sep = "")
```

```
## [1] "STAT547M"
```

```r
paste0("STAT", "547M")
```

```
## [1] "STAT547M"
```

```r
# modify the separator in paste() to have different output
paste("STAT", "547M", sep = " ")
```

```
## [1] "STAT 547M"
```

**What stringr function are they equivalent to?**

`str_c()` is equaivalent to `paste()` and `paste0()`. The usage of `str_c()` is:

`str_c(..., sep = "", collapse = NULL)`

Here are two examples.


```r
# the default str_c() (without sep) is the same as paste0()
str_c("STAT", "547M")
```

```
## [1] "STAT547M"
```

```r
# with sep, str_c() is the same as paste()
str_c("STAT", "547M", sep = " ")
```

```
## [1] "STAT 547M"
```

**How do the functions differ in their handling of `NA`?**  

For `paste()` and `paste0()`, `NA` is directly convert to a string "NA", and concatenate with other strings. However, if `NA` is one of the input strings for `str_c()`, the output of `str_c()` will become `NA`.


```r
# paste() and paste0() convert NA to a string
paste("NA is ", NA, sep = "")
```

```
## [1] "NA is NA"
```

```r
paste0("NA is ", NA)
```

```
## [1] "NA is NA"
```

```r
# str_c() returns NA is one of the input strings is NA
str_c("NA is ", NA)
```

```
## [1] NA
```

### Question 2

**In your own words, describe the difference between the `sep` and `collapse` arguments to `str_c()`.**

`sep` and `collapse` try to handle two different types of inputs. If we use multiple strings as input, the string defined in `sep` will be added between two neighboring input strings. If we use a vector as an input and `collapse` is defined, `str_c()` tries to combine strings inside the vector, and add the string defined in `collapse` between two neiboring strings.


```r
# let's create two vector to concatenate
stat_547m <- c("STAT", "547M")
subject_code <- c("Department", "Code")

# sep is used for input strings
str_c("STAT", "547M", sep = " ")
```

```
## [1] "STAT 547M"
```

```r
# since str_c() concatenate vectors by item, if only one vector is input, it will not be concatenated
str_c(stat_547m, sep = " ")
```

```
## [1] "STAT" "547M"
```

```r
# use collapse to concatenate vector
str_c(stat_547m, collapse = " ")
```

```
## [1] "STAT 547M"
```

```r
# we can use sep to concatenate two vectors by items
str_c(subject_code, stat_547m, sep = ": ")
```

```
## [1] "Department: STAT" "Code: 547M"
```

```r
# we can use sep and collapse together to concatenate two vectors into one string
str_c(subject_code, stat_547m, sep = ": ", collapse = ", ")
```

```
## [1] "Department: STAT, Code: 547M"
```

### Question 3

**Use `str_length()` and `str_sub()` to extract the middle character from a string.**


```r
# create two strings for this question, with odd number of characters
string_odd <- "oddnumber"

# let's define a function to get the middle index of a string with odd number of characters
func_index_odd <- function(s) {
  return(str_length(s) / 2 + 1)
}

# extract the middle character of string_odd, which is u
index_odd <- func_index_odd(string_odd)
str_sub(string_odd, index_odd, index_odd)
```

```
## [1] "u"
```


**What will you do if the string has an even number of characters?**

We try to get the middle two characters if the number of characters in a string is an even number.


```r
# create two strings for this question, with even number of characters
string_even <- "evennumber"

# let's define a function to get the LEFT middle index of a string with even umber of characters
func_index_even <- function(s) {
  return(str_length(s) / 2)
}

# extract the middle two characters of string_even, which are nu. here we need to add 1 for the end index
index_even <- func_index_even(string_even)
str_sub(string_even, index_even, index_even + 1)
```

```
## [1] "nu"
```

### Question 4

**What does `str_wrap()` do? When might you want to use it?**

According to `?str_wrap`, this function tries to wrap paragraph into multiple lines using an algorithm called "Knuth-Plass paragraph wrapping algorithm". An introduction of this algorithm can be found [here](https://www.ugrad.cs.ubc.ca/~cs490/2015W2/lectures/Knuth.pdf).

Therefore, if we want to show a long paragraph, and fit it into a page, we can try to use `str_wrap()`. Here we have an example extracted form the page of [Homework 06](http://stat545.com/Classroom/assignments/hw06/hw06.html).


```r
# a very long paragraph
long_paragraph <- "Exceeded the requirements in number of dimensions. Developed novel tasks that were indeed interesting and 'worked'. Impressive use of R - maybe involving functions, packages or workflows that weren't given in class materials. Impeccable organization of repo and report. You learned something new from reviewing their work and you're eager to incorporate it into your work."

# let's try to print it without wrapping
cat(long_paragraph)
```

```
## Exceeded the requirements in number of dimensions. Developed novel tasks that were indeed interesting and 'worked'. Impressive use of R - maybe involving functions, packages or workflows that weren't given in class materials. Impeccable organization of repo and report. You learned something new from reviewing their work and you're eager to incorporate it into your work.
```

```r
# let's try to print it after wrapping, and seperate by new line
cat(str_wrap(long_paragraph), sep = "\n")
```

```
## Exceeded the requirements in number of dimensions. Developed novel tasks that
## were indeed interesting and 'worked'. Impressive use of R - maybe involving
## functions, packages or workflows that weren't given in class materials.
## Impeccable organization of repo and report. You learned something new from
## reviewing their work and you're eager to incorporate it into your work.
```

The length of each line after wrapping are almost the same.

### Question 5

**What does `str_trim()` do?**

`str_trim()` deletes all starting and ending spaces from a string.


```r
# create a string for testing
string_with_spaces = "  STAT 547M  "

# use str_trim() to delete all spaces at the beginning and the end of the string
string_no_spaces <- str_trim(string_with_spaces)
string_no_spaces
```

```
## [1] "STAT 547M"
```


**What's the opposite of `str_trim()`?**

We can use `str_pad()` to add spaces or other characters. The usage of `str_pad()` is:

`str_pad(string, width, side = c("left", "right", "both"), pad = " ")`

We try to pad `string_no_sapces` back to `string_with_spaces`. Notice that, we need to add two spaces both at the beginning and the end of the string, which means we need to make the width of the final string 4 characters more.


```r
# we try to pad string_no_spaces back to string_with_spaces
str_pad(string_no_spaces,
        width = str_length(string_no_spaces) + 4,
        side = c("both"),
        pad = " ")
```

```
## [1] "  STAT 547M  "
```

### Question 6

**Write a function that turns (e.g.) a vector `c("a", "b", "c")` into the string `a`, `b`, and `c`. Think carefully about what it should do if given a vector of length 0, 1, or 2.**

Assuming the final string is "a, b, and c", we make the following rules for the function:

- If the length of vector is 0, we return an empty string (""); 
- If the length of vector is 1, we return the string inside the vector (e.g., "a");
- If the length of vector is 2, we follow the same format as the length is 3 or above, which means we return, for example, "a, and b".


```r
# function to convert vector into a string
vector_to_string <- function(v) {
  if (length(v) == 0) {
    return("")
  } else if (length(v) == 1) {
    return(v)
  } else {
    # first, convert all elements except the last one into a string
    first_part <- str_c(v[-length(v)], collapse = ", ")
    # second, add the last element with "and"
    whole_string <- str_c(first_part, v[length(v)], sep = ", and ")
    # return the final string
    return(whole_string)
  }
}
```

Let's use `testthat` package to test our function.


```r
# create four vectors to test
l0 <- c()
l1 <- c("a")
l2 <- c("a", "b")
l3 <- c ("a", "b", "c")

# create test suite
test_that("function vector_to_string() is wrong", {
  # test case 1: vector length of 0
  expect_equal(vector_to_string(l0), "")
  # test case 2: vector length of 1
  expect_equal(vector_to_string(l1), "a")
  # test case 3: vector length of 2
  expect_equal(vector_to_string(l2), "a, and b")
  # test case 4: vector length of 3
  expect_equal(vector_to_string(l3), "a, b, and c")
})
```

All the above tests are passed.

## Exercises 14.3.1.1

### Question 1

**Explain why each of these strings don't match a \\: "\\", "\\\\", "\\\\\\".**

"\\" is an escape character in both R and regex (writtern inside R). Therefore:

- "\\" is an escape character in R, which leads to an R error (incomplete expression).
- "\\\\" will be treated as one back slash ("\\") in R, which becomes an escape character in regex (writtern inside R), and therefore leads to a regex error.
- Similarly, "\\\\\\" will be treated as a back slash with an escape character in regex (writtern inside R), which also leads to a regex error.

The following is an sucessful example using "\\\\\\\\" to match a "\\".


```r
# create a string to test
test_back_slash <- "STAT\\547M"

str_view(test_back_slash, pattern = "\\\\", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-cf5aca6265f689060f2a" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-cf5aca6265f689060f2a">{"x":{"html":"<ul>\n  <li>STAT<span class='match'>\\<\/span>547M<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->



### Question 2

**How would you match the sequence "'\\?**

Since both "'" and "\\" needs to be escaped in regex, we need to use "\\'\\\\" to match it.


```r
# create a string to test
test_back_slash <- "STAT'\\547M"

# use str_view() for matching
str_view(test_back_slash, pattern = "\\'\\\\", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-e80f249298cfe57a0371" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-e80f249298cfe57a0371">{"x":{"html":"<ul>\n  <li>STAT<span class='match'>'\\<\/span>547M<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->


### Question 3

**What patterns will the regular expression \\..\\..\\.. match? How would you represent it as a string?**

Regex "\\..\\..\\.." can match a string with six characters: a dot follows by any character, follows by another dot and a another character, then end with a dot follows by another character. Here is an example, "a", "b", or "c" can be any other characters.


```r
# create a string to test
test_pattern <- "STAT.a.b.c547M"

# use str_view() for matching
str_view(test_pattern, pattern = "\\..\\..\\..", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-48a85e22b7787b8b1f30" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-48a85e22b7787b8b1f30">{"x":{"html":"<ul>\n  <li>STAT<span class='match'>.a.b.c<\/span>547M<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

## Exercises 14.3.2.1

### Question 1

**How would you match the literal string "\$^\$"?**

We need to escape both "\$" and "^" in regex. Therefore, "\\\\\$\\\\^\\\\\$" is a suitable pattern.


```r
# create a string to test
test_pattern <- "STAT$^$547M"

# use str_view() for matching
str_view(test_pattern, pattern = "\\$\\^\\$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-aecec2cca504563ec93a" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-aecec2cca504563ec93a">{"x":{"html":"<ul>\n  <li>STAT<span class='match'>$^$<\/span>547M<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

### Question 2

**Given the corpus of common words in `stringr::words`, create regular expressions that find all words that fulfilling the following requirements. Since this list is long, you might want to use the `match` argument to `str_view()` to show only the matching or non-matching words.**

**Requirement 1: start with "y".**


```r
# find words start with "y"
str_view(stringr::words, pattern = "^y", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-e31da29e4b93bc376ebd" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-e31da29e4b93bc376ebd">{"x":{"html":"<ul>\n  <li><span class='match'>y<\/span>ear<\/li>\n  <li><span class='match'>y<\/span>es<\/li>\n  <li><span class='match'>y<\/span>esterday<\/li>\n  <li><span class='match'>y<\/span>et<\/li>\n  <li><span class='match'>y<\/span>ou<\/li>\n  <li><span class='match'>y<\/span>oung<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->


**Requirement 2: End with "x".**


```r
# find words end with "x"
str_view(stringr::words, pattern = "x$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-76d8177c1c2acc0adc55" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-76d8177c1c2acc0adc55">{"x":{"html":"<ul>\n  <li>bo<span class='match'>x<\/span><\/li>\n  <li>se<span class='match'>x<\/span><\/li>\n  <li>si<span class='match'>x<\/span><\/li>\n  <li>ta<span class='match'>x<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 3: are exactly three letters long. (Don't cheat by using `str_length()`!).**


```r
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))
```



|Selected Words |
|:--------------|
|address        |
|air            |
|assume         |
|authority      |
|chap           |
|clothe         |
|fun            |
|happen         |
|heavy          |
|it             |
|let            |
|moment         |
|note           |
|or             |
|small          |
|spell          |
|square         |
|too            |
|treat          |
|west           |

```r
# find words that are exactly three letters long
str_view(stringr::words[index], pattern = "^.{3}$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-78b76aec49f3b17d8fbc" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-78b76aec49f3b17d8fbc">{"x":{"html":"<ul>\n  <li><span class='match'>fun<\/span><\/li>\n  <li><span class='match'>air<\/span><\/li>\n  <li><span class='match'>too<\/span><\/li>\n  <li><span class='match'>let<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 4: have seven letters or more.**


```r
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))
```



|Selected Words |
|:--------------|
|afford         |
|by             |
|case           |
|control        |
|design         |
|double         |
|europe         |
|force          |
|god            |
|law            |
|level          |
|mother         |
|pound          |
|price          |
|quarter        |
|responsible    |
|set            |
|sit            |
|society        |
|special        |

```r
# find words that have seven letters or more
str_view(stringr::words[index], pattern = "^.{7,}$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-2f6ad49e04f365b0d158" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-2f6ad49e04f365b0d158">{"x":{"html":"<ul>\n  <li><span class='match'>responsible<\/span><\/li>\n  <li><span class='match'>control<\/span><\/li>\n  <li><span class='match'>quarter<\/span><\/li>\n  <li><span class='match'>special<\/span><\/li>\n  <li><span class='match'>society<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->


## Exercises 14.3.3.1

### Question 1

**Create regular expressions to find all words that fulfull the following requirements.**

**Requirement 1: start with a vowel.**


```r
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))
```



|Selected Words |
|:--------------|
|answer         |
|big            |
|break          |
|brother        |
|club           |
|day            |
|expense        |
|floor          |
|inform         |
|lad            |
|like           |
|occasion       |
|past           |
|place          |
|saturday       |
|science        |
|some           |
|summer         |
|tea            |
|tie            |

```r
# find words that start with a vowel
str_view(stringr::words[index], pattern = "^[aeiou]", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-180b969c328319f26157" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-180b969c328319f26157">{"x":{"html":"<ul>\n  <li><span class='match'>e<\/span>xpense<\/li>\n  <li><span class='match'>o<\/span>ccasion<\/li>\n  <li><span class='match'>i<\/span>nform<\/li>\n  <li><span class='match'>a<\/span>nswer<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 2: that only contain consonants. (Hint: thinking about matching "not"-vowels.)**

We change `match` to `FALSE` in order to show words that does not contains vowels, which fulfulls the requirement.


```r
# find words that without a vowel
str_view(stringr::words, pattern = "[aeiou]", match = FALSE)
```

<!--html_preserve--><div id="htmlwidget-b7555211eecf9437371a" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-b7555211eecf9437371a">{"x":{"html":"<ul>\n  <li>by<\/li>\n  <li>dry<\/li>\n  <li>fly<\/li>\n  <li>mrs<\/li>\n  <li>try<\/li>\n  <li>why<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 3: end with `ed`, but not with `eed`.**


```r
# find words that end with "ed" but not "eed"
str_view(stringr::words, pattern = "[^e]ed$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-9ad1731bb67e76283b37" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-9ad1731bb67e76283b37">{"x":{"html":"<ul>\n  <li><span class='match'>bed<\/span><\/li>\n  <li>hund<span class='match'>red<\/span><\/li>\n  <li><span class='match'>red<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 4: end with `ing` or `ise`.**


```r
# find words that end with "ing" or "ise"
str_view(stringr::words, pattern = "ing$|ise$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-23851790abf7966d81e6" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-23851790abf7966d81e6">{"x":{"html":"<ul>\n  <li>advert<span class='match'>ise<\/span><\/li>\n  <li>br<span class='match'>ing<\/span><\/li>\n  <li>dur<span class='match'>ing<\/span><\/li>\n  <li>even<span class='match'>ing<\/span><\/li>\n  <li>exerc<span class='match'>ise<\/span><\/li>\n  <li>k<span class='match'>ing<\/span><\/li>\n  <li>mean<span class='match'>ing<\/span><\/li>\n  <li>morn<span class='match'>ing<\/span><\/li>\n  <li>otherw<span class='match'>ise<\/span><\/li>\n  <li>pract<span class='match'>ise<\/span><\/li>\n  <li>ra<span class='match'>ise<\/span><\/li>\n  <li>real<span class='match'>ise<\/span><\/li>\n  <li>r<span class='match'>ing<\/span><\/li>\n  <li>r<span class='match'>ise<\/span><\/li>\n  <li>s<span class='match'>ing<\/span><\/li>\n  <li>surpr<span class='match'>ise<\/span><\/li>\n  <li>th<span class='match'>ing<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

### Question 2

**Empirically verify the rule "i before e except after c".**

To solve this question, it means we need to ensure:

- The number of "ie" and the number of "cei" are high enough.
- The number of "ei" and the number of "cie" are low enough.

Therefore, we try the following to regexes.


```r
# subset words with "ie" and "cei"
high_subset <- str_subset(stringr::words, pattern = "[^c]ie|cei")
high_subset %>% 
  knitr::kable(col.names = c("Words with \"ie\" or \"cei\""))
```



|Words with "ie" or "cei" |
|:------------------------|
|achieve                  |
|believe                  |
|brief                    |
|client                   |
|die                      |
|experience               |
|field                    |
|friend                   |
|lie                      |
|piece                    |
|quiet                    |
|receive                  |
|tie                      |
|view                     |

```r
# subset words with "ei" and "cie"
low_subset <- str_subset(stringr::words, pattern = "[^c]ei|cie")
low_subset %>% 
  knitr::kable(col.names = c("Words with \"ei\" or \"cie\""))
```



|Words with "ei" or "cie" |
|:------------------------|
|science                  |
|society                  |
|weigh                    |

```r
# perform a test showing that there are more words in subset 1 than subset 2
test_that("The rule is not correct", {
  expect_more_than(length(high_subset), length(low_subset))
})
```

So the rule is empirically verified.

### Question 3

**Is "q" always followed by a "u"?**

To solve this question, it means we need to ensure there is no match for "q followed by not u".

Therefore, we try the following to regexes.


```r
# check if there is "q followed by not u"
str_view(stringr::words, pattern = "q[^u]", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-f829f2c083da98293817" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-f829f2c083da98293817">{"x":{"html":"<ul>\n  <li><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

The result is empty, so the statement is true.

### Question 4

**Write a regular expression that matches a word if it's probably written in British English, not American English.**

According to [this reference](https://learningenglish.voanews.com/a/six-difference-between-britsh-and-american-english/3063743.html), there are spelling differences in British English and American English. For example, in American English, "u" is dropped in some words end with "our" (which means only "or" is kept, e.g. "colour" and "color"). We can create a regex and use some examples to show it.


```r
# create some words to test
test_words <- c("colour", "color", "honour", "honor", "labor", "labour")

# use a regex to detect American English
str_view(test_words, pattern = ".+or$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-e4957dde05626c77314c" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-e4957dde05626c77314c">{"x":{"html":"<ul>\n  <li><span class='match'>color<\/span><\/li>\n  <li><span class='match'>honor<\/span><\/li>\n  <li><span class='match'>labor<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

### Question 5

**Create a regular expression that will match telephone numbers as commonly written in your country.**

The telephone numbers in Canada follow the following rule: "+1 (111) 111 1111". Therefore we can use the following regex to detect it.


```r
# create some telephone numbers to test
test_telephone_numbers <- c("+1 (778) 069 2357", "+86 139 392 2560", "+852 2309 9667")

# use a regex to detect telephone numbers in Canada
str_view(test_telephone_numbers, pattern = "\\+1 \\([1-9][0-9]{2}\\) [0-9]{3} [0-9]{4}")
```

<!--html_preserve--><div id="htmlwidget-070681a3d2169b43abdc" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-070681a3d2169b43abdc">{"x":{"html":"<ul>\n  <li><span class='match'>+1 (778) 069 2357<\/span><\/li>\n  <li>+86 139 392 2560<\/li>\n  <li>+852 2309 9667<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

## Exercises 14.3.4.1

### Question 1

**Describe the equivalents of `?`, `+`, `*` in {m,n} form.**

- `?` is equivalent to {0,1},
- `+` is equivalent to {1,}.
- `*` is equivalent to {0,}.

### Question 2

**Describe in words what these regular expressions match: (read carefully to see if I'm using a regular expression or a string that defines a regular expression.)**

- ^.*$ matches any string.
- "\\\\{.+\\\\}" matches word with at least one character, which is surrounded by a pair of curly brackets, for example "{abc}".
- \\d{4}-\\d{2}-\\d{2} matches a string looks like dddd-dd-dd, where d is digit. For example, "1234-56-78".
- "\\\\\\\\{4}" matches four back slashes.

### Question 3

**Create regular expressions to find all words that fulfill the following requirements.**

**Requirement 1: start with three consonants.**


```r
# find words that start with three consonants
str_view(stringr::words, pattern = "^[^aeoiu]{3,}", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-a80b16c044e96225f90f" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-a80b16c044e96225f90f">{"x":{"html":"<ul>\n  <li><span class='match'>Chr<\/span>ist<\/li>\n  <li><span class='match'>Chr<\/span>istmas<\/li>\n  <li><span class='match'>dry<\/span><\/li>\n  <li><span class='match'>fly<\/span><\/li>\n  <li><span class='match'>mrs<\/span><\/li>\n  <li><span class='match'>sch<\/span>eme<\/li>\n  <li><span class='match'>sch<\/span>ool<\/li>\n  <li><span class='match'>str<\/span>aight<\/li>\n  <li><span class='match'>str<\/span>ategy<\/li>\n  <li><span class='match'>str<\/span>eet<\/li>\n  <li><span class='match'>str<\/span>ike<\/li>\n  <li><span class='match'>str<\/span>ong<\/li>\n  <li><span class='match'>str<\/span>ucture<\/li>\n  <li><span class='match'>syst<\/span>em<\/li>\n  <li><span class='match'>thr<\/span>ee<\/li>\n  <li><span class='match'>thr<\/span>ough<\/li>\n  <li><span class='match'>thr<\/span>ow<\/li>\n  <li><span class='match'>try<\/span><\/li>\n  <li><span class='match'>typ<\/span>e<\/li>\n  <li><span class='match'>why<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 2: have three or more vowels in a row.**


```r
# find words that have three or more vowels in a row
str_view(stringr::words, pattern = "[aeoiu]{3,}", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-056a735a5ea519df33dc" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-056a735a5ea519df33dc">{"x":{"html":"<ul>\n  <li>b<span class='match'>eau<\/span>ty<\/li>\n  <li>obv<span class='match'>iou<\/span>s<\/li>\n  <li>prev<span class='match'>iou<\/span>s<\/li>\n  <li>q<span class='match'>uie<\/span>t<\/li>\n  <li>ser<span class='match'>iou<\/span>s<\/li>\n  <li>var<span class='match'>iou<\/span>s<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 3: have two or more vowel-consonant pairs in a row.**


```r
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))
```



|Selected Words |
|:--------------|
|afternoon      |
|condition      |
|every          |
|four           |
|heavy          |
|how            |
|however        |
|lay            |
|listen         |
|news           |
|pence          |
|range          |
|real           |
|responsible    |
|saturday       |
|start          |
|street         |
|union          |
|watch          |
|water          |

```r
# find words that have two or more vowel-consonant pairs in a row
str_view(stringr::words[index], pattern = "([aeoui][^aeoiu]){2,}", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-d849dba5d8065e4cd0ec" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-d849dba5d8065e4cd0ec">{"x":{"html":"<ul>\n  <li>h<span class='match'>owever<\/span><\/li>\n  <li><span class='match'>ever<\/span>y<\/li>\n  <li>w<span class='match'>ater<\/span><\/li>\n  <li>s<span class='match'>atur<\/span>day<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

### Question 4

**Solve the beginner regexp crosswords [here](https://regexcrossword.com/challenges/beginner).**

The following images are the results for the crosswords.

![](./crosswords/1.png)
![](./crosswords/2.png)
![](./crosswords/3.png)
![](./crosswords/4.png)
![](./crosswords/5.png)

## Exercises 14.3.5.1

### Question 1

**Describe, in words, what these expressions will match:**

- (.)\\1\\1 matches a character appers three times, for example "aaa".
- "(.)(.)\\\\2\\\\1" matches two characters and their reversal, for example "abba".
- (..)\\1 matches a set of two characters appear two times, for example "abab".
- "(.).\\\\1.\\\\1" matches a string with five characters: the first character appears again at the third and fifth places, while the second and forth places are any two characters. For example, "abaca".
- "(.)(.)(.).*\\\\3\\\\2\\\\1" matches a set of three characters appears at the beginning, then follows by any characters (0 or more), then the reversal of the begining three characters. For example, "abcxxxxxxcba".

### Question 2

**Construct regular expressions to match words that fullfill the following requirements.**

**Requirement 1: start and end with the same character.**


```r
# find words that start and end with the same character
str_view(stringr::words, pattern = "^(.).*\\1$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-a531a3ae00988633bc09" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-a531a3ae00988633bc09">{"x":{"html":"<ul>\n  <li><span class='match'>america<\/span><\/li>\n  <li><span class='match'>area<\/span><\/li>\n  <li><span class='match'>dad<\/span><\/li>\n  <li><span class='match'>dead<\/span><\/li>\n  <li><span class='match'>depend<\/span><\/li>\n  <li><span class='match'>educate<\/span><\/li>\n  <li><span class='match'>else<\/span><\/li>\n  <li><span class='match'>encourage<\/span><\/li>\n  <li><span class='match'>engine<\/span><\/li>\n  <li><span class='match'>europe<\/span><\/li>\n  <li><span class='match'>evidence<\/span><\/li>\n  <li><span class='match'>example<\/span><\/li>\n  <li><span class='match'>excuse<\/span><\/li>\n  <li><span class='match'>exercise<\/span><\/li>\n  <li><span class='match'>expense<\/span><\/li>\n  <li><span class='match'>experience<\/span><\/li>\n  <li><span class='match'>eye<\/span><\/li>\n  <li><span class='match'>health<\/span><\/li>\n  <li><span class='match'>high<\/span><\/li>\n  <li><span class='match'>knock<\/span><\/li>\n  <li><span class='match'>level<\/span><\/li>\n  <li><span class='match'>local<\/span><\/li>\n  <li><span class='match'>nation<\/span><\/li>\n  <li><span class='match'>non<\/span><\/li>\n  <li><span class='match'>rather<\/span><\/li>\n  <li><span class='match'>refer<\/span><\/li>\n  <li><span class='match'>remember<\/span><\/li>\n  <li><span class='match'>serious<\/span><\/li>\n  <li><span class='match'>stairs<\/span><\/li>\n  <li><span class='match'>test<\/span><\/li>\n  <li><span class='match'>tonight<\/span><\/li>\n  <li><span class='match'>transport<\/span><\/li>\n  <li><span class='match'>treat<\/span><\/li>\n  <li><span class='match'>trust<\/span><\/li>\n  <li><span class='match'>window<\/span><\/li>\n  <li><span class='match'>yesterday<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 2: contain a repeated pair of letters (e.g. "church" contains "ch" repeated twice.)**


```r
# find words that contain a repeated pair of letters
str_view(stringr::words, pattern = "(..).*\\1", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-ab6ead55e6e7ef0ee036" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ab6ead55e6e7ef0ee036">{"x":{"html":"<ul>\n  <li>ap<span class='match'>propr<\/span>iate<\/li>\n  <li><span class='match'>church<\/span><\/li>\n  <li>c<span class='match'>ondition<\/span><\/li>\n  <li><span class='match'>decide<\/span><\/li>\n  <li><span class='match'>environmen<\/span>t<\/li>\n  <li>l<span class='match'>ondon<\/span><\/li>\n  <li>pa<span class='match'>ragra<\/span>ph<\/li>\n  <li>p<span class='match'>articular<\/span><\/li>\n  <li><span class='match'>photograph<\/span><\/li>\n  <li>p<span class='match'>repare<\/span><\/li>\n  <li>p<span class='match'>ressure<\/span><\/li>\n  <li>r<span class='match'>emem<\/span>ber<\/li>\n  <li><span class='match'>repre<\/span>sent<\/li>\n  <li><span class='match'>require<\/span><\/li>\n  <li><span class='match'>sense<\/span><\/li>\n  <li>the<span class='match'>refore<\/span><\/li>\n  <li>u<span class='match'>nderstand<\/span><\/li>\n  <li>w<span class='match'>hethe<\/span>r<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

**Requirement 3: contain one letter repeated in at least three places (e.g. "eleven" contains three "e"s.)**


```r
# find words that contain one letter repeated in at least three places
str_view(stringr::words, pattern = "(.).*\\1.*\\1", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-7fac862510e283b22e16" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-7fac862510e283b22e16">{"x":{"html":"<ul>\n  <li>a<span class='match'>pprop<\/span>riate<\/li>\n  <li><span class='match'>availa<\/span>ble<\/li>\n  <li>b<span class='match'>elieve<\/span><\/li>\n  <li>b<span class='match'>etwee<\/span>n<\/li>\n  <li>bu<span class='match'>siness<\/span><\/li>\n  <li>d<span class='match'>egree<\/span><\/li>\n  <li>diff<span class='match'>erence<\/span><\/li>\n  <li>di<span class='match'>scuss<\/span><\/li>\n  <li><span class='match'>eleve<\/span>n<\/li>\n  <li>e<span class='match'>nvironmen<\/span>t<\/li>\n  <li><span class='match'>evidence<\/span><\/li>\n  <li><span class='match'>exercise<\/span><\/li>\n  <li><span class='match'>expense<\/span><\/li>\n  <li><span class='match'>experience<\/span><\/li>\n  <li><span class='match'>indivi<\/span>dual<\/li>\n  <li>p<span class='match'>aragra<\/span>ph<\/li>\n  <li>r<span class='match'>eceive<\/span><\/li>\n  <li>r<span class='match'>emembe<\/span>r<\/li>\n  <li>r<span class='match'>eprese<\/span>nt<\/li>\n  <li>t<span class='match'>elephone<\/span><\/li>\n  <li>th<span class='match'>erefore<\/span><\/li>\n  <li>t<span class='match'>omorro<\/span>w<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

## Exercises 14.4.2

### Question 1

**For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple `str_detect()` calls.**

**Find all words that start or end with x.**


```r
# single regex
str_subset(stringr::words, pattern = "^x|x$") %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|box            |
|sex            |
|six            |
|tax            |

```r
# multiple str_detect() calls
# find positions start with x
c1 <- str_detect(stringr::words, pattern = "^x")
# find positions end with x
c2 <- str_detect(stringr::words, pattern = "x$")
# find subset that start or end with x
stringr::words %>% 
  `[`(c1 | c2) %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|box            |
|sex            |
|six            |
|tax            |


**Find all words that start with a vowel and end with a consonant.**


```r
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))
```



|Selected Words |
|:--------------|
|apparent       |
|bad            |
|birth          |
|bloke          |
|boat           |
|correct        |
|date           |
|dear           |
|film           |
|floor          |
|form           |
|half           |
|mark           |
|of             |
|old            |
|paragraph      |
|respect        |
|spend          |
|usual          |
|war            |

```r
# single regex
str_subset(stringr::words[index], pattern = "^[aeiou].*[^aeiou]$") %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|apparent       |
|old            |
|usual          |
|of             |

```r
# multiple str_detect() calls
# find positions start with x
c1 <- str_detect(stringr::words[index], pattern = "^[aeiou]")
# find positions end with x
c2 <- str_detect(stringr::words[index], pattern = "[^aeiou]$")
# find subset that start or end with x
stringr::words %>% 
  `[`(index) %>% 
  `[`(c1 & c2) %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|apparent       |
|old            |
|usual          |
|of             |

**Are there any words that contain at least one of each different vowel?**

It is not possible to find a single regex to solve this question. However, it is easy to solve using `str_detect()`.


```r
# multiple str_detect() calls
# define a function for our task
contain_each_vowel <- function(s) {
  # vowels to check
  vowels <- c("a", "e", "i", "o", "u")
  # original results
  check <- as.logical(seq(from = 1, to = 1, along.with = s))
  # check vowels one by one
  for (vowel in vowels) {
    check <- check & str_detect(s, pattern = vowel)
  }
  # return whether s contain at least one of each different vowel
  return(s[check])
}

# create a test case
test_that("function contain_each_vowel() not works", {
  test_string <- "aberixowu"
  
  expect_equal(test_string, contain_each_vowel(test_string))
})
```

### Question 2

**What word has the highest number of vowels?**


```r
# count the number of vowels in words
num_vowels <- str_count(stringr::words, pattern = "[aeiou]")

# find the words with the highest number of vowels
stringr::words %>% 
  `[`(which(num_vowels == max(num_vowels))) %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|appropriate    |
|associate      |
|available      |
|colleague      |
|encourage      |
|experience     |
|individual     |
|television     |


**What word has the highest proportion of vowels? (Hint: what is the denominator?)**


```r
# calcuate the proportion of vowels in words
prop_vowels <- str_count(stringr::words, pattern = "[aeiou]") / str_length(stringr::words)

# find the words with the highest number of vowels
stringr::words %>% 
  `[`(which(prop_vowels == max(prop_vowels))) %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|a              |

The result is reasonable because word "a" has 100% vowel(s).

## Exercises 14.4.3.1

### Question 1

### Question 2

## Exercises 14.4.4.1

### Question 1

### Question 2

## Exercises 14.4.5.1

### Question 1

### Question 2

### Question 3

## Exercises 14.4.6.1

### Question 1

### Question 2

### Question 3

## Exercises 14.5.1

### Question 1

### Question 2

## Exercises 14.7.1

### Question 1

### Question 2

# Task 2: Work with the `single` data
