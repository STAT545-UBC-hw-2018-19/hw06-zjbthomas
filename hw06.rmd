---
title: "STAT 547M Homework 6"
author: "Junbin ZHANG"
date: "Oct 30, 2018"
output:
  html_document:
    keep_md: true
    toc: true
    toc_depth: 2
    theme: readable
---

# Bring rectangular data in
```{r}
## load gapminder
suppressPackageStartupMessages(library(gapminder))
## load tidyverse
suppressPackageStartupMessages(library(tidyverse))
## load testthat
suppressPackageStartupMessages(library(testthat))
## load stringi
suppressPackageStartupMessages(library(stringi))
## load leaflet
suppressPackageStartupMessages(library(leaflet))
```

# Install and load `singer` package

```{r}
## install singer
# install.packages("devtools")
# devtools::install_github("JoeyBernhardt/singer")
## load singer
suppressPackageStartupMessages(library(singer))
```

# Install and load `ggmap` package

```{r}
## install ggmap
# install.packages("devtools")
# devtools::install_github("dkahle/ggmap", ref = "tidyup")
## load ggmap
suppressPackageStartupMessages(library(ggmap))
## register API key (please do not use this key for any other purpose, thank you)
register_google(key = "AIzaSyBsFRsHrAmuPDmcWd-7D5AbENG6_XreKDo")
```

# Task 1: Character data

## Exercises 14.2.5

### Question 1

**In code that doesn't use stringr, you'll often see `paste()` and `paste0()`. What's the difference between the two functions?**

The usages of `paste()` and `paste0()` can be obtained by running `?paste` in console, and they are listed as followed.

`paste (..., sep = " ", collapse = NULL)`

`paste0(..., collapse = NULL)`

So the difference is, `paste()` allows us to add an separator between strings we want to concatenate. Let's try to use `paste()` and `paste0()` to show their differences.
  
```{r}
# make paste() and paste0() have the same outputs
paste("STAT", "547M", sep = "")
paste0("STAT", "547M")

# modify the separator in paste() to have different output
paste("STAT", "547M", sep = " ")
```

**What stringr function are they equivalent to?**

`str_c()` is equaivalent to `paste()` and `paste0()`. The usage of `str_c()` is:

`str_c(..., sep = "", collapse = NULL)`

Here are two examples.

```{r}
# the default str_c() (without sep) is the same as paste0()
str_c("STAT", "547M")

# with sep, str_c() is the same as paste()
str_c("STAT", "547M", sep = " ")
```

**How do the functions differ in their handling of `NA`?**  

For `paste()` and `paste0()`, `NA` is directly convert to a string "NA", and concatenate with other strings. However, if `NA` is one of the input strings for `str_c()`, the output of `str_c()` will become `NA`.

```{r}
# paste() and paste0() convert NA to a string
paste("NA is ", NA, sep = "")
paste0("NA is ", NA)

# str_c() returns NA is one of the input strings is NA
str_c("NA is ", NA)
```

### Question 2

**In your own words, describe the difference between the `sep` and `collapse` arguments to `str_c()`.**

`sep` and `collapse` try to handle two different types of inputs. If we use multiple strings as input, the string defined in `sep` will be added between two neighboring input strings. If we use a vector as an input and `collapse` is defined, `str_c()` tries to combine strings inside the vector, and add the string defined in `collapse` between two neiboring strings.

```{r}
# let's create two vector to concatenate
stat_547m <- c("STAT", "547M")
subject_code <- c("Department", "Code")

# sep is used for input strings
str_c("STAT", "547M", sep = " ")

# since str_c() concatenate vectors by item, if only one vector is input, it will not be concatenated
str_c(stat_547m, sep = " ")

# use collapse to concatenate vector
str_c(stat_547m, collapse = " ")

# we can use sep to concatenate two vectors by items
str_c(subject_code, stat_547m, sep = ": ")

# we can use sep and collapse together to concatenate two vectors into one string
str_c(subject_code, stat_547m, sep = ": ", collapse = ", ")
```

### Question 3

**Use `str_length()` and `str_sub()` to extract the middle character from a string.**

```{r}
# create two strings for this question, with odd number of characters
string_odd <- "oddnumber"

# let's define a function to get the middle index of a string with odd number of characters
func_index_odd <- function(s) {
  return(str_length(s) / 2 + 1)
}

# extract the middle character of string_odd, which is u
index_odd <- func_index_odd(string_odd)
str_sub(string_odd, index_odd, index_odd)
```


**What will you do if the string has an even number of characters?**

We try to get the middle two characters if the number of characters in a string is an even number.

```{r}
# create two strings for this question, with even number of characters
string_even <- "evennumber"

# let's define a function to get the LEFT middle index of a string with even umber of characters
func_index_even <- function(s) {
  return(str_length(s) / 2)
}

# extract the middle two characters of string_even, which are nu. here we need to add 1 for the end index
index_even <- func_index_even(string_even)
str_sub(string_even, index_even, index_even + 1)
```

### Question 4

**What does `str_wrap()` do? When might you want to use it?**

According to `?str_wrap`, this function tries to wrap paragraph into multiple lines using an algorithm called "Knuth-Plass paragraph wrapping algorithm". An introduction of this algorithm can be found [here](https://www.ugrad.cs.ubc.ca/~cs490/2015W2/lectures/Knuth.pdf).

Therefore, if we want to show a long paragraph, and fit it into a page, we can try to use `str_wrap()`. Here we have an example extracted form the page of [Homework 06](http://stat545.com/Classroom/assignments/hw06/hw06.html).

```{r}
# a very long paragraph
long_paragraph <- "Exceeded the requirements in number of dimensions. Developed novel tasks that were indeed interesting and \"worked\". Impressive use of R - maybe involving functions, packages or workflows that weren't given in class materials. Impeccable organization of repo and report. You learned something new from reviewing their work and you're eager to incorporate it into your work."

# let's try to print it without wrapping
cat(long_paragraph)

# let's try to print it after wrapping, and seperate by new line
cat(str_wrap(long_paragraph), sep = "\n")
```

The length of each line after wrapping are almost the same.

### Question 5

**What does `str_trim()` do?**

`str_trim()` deletes all starting and ending spaces from a string.

```{r}
# create a string for testing
string_with_spaces = "  STAT 547M  "

# use str_trim() to delete all spaces at the beginning and the end of the string
string_no_spaces <- str_trim(string_with_spaces)
string_no_spaces
```


**What's the opposite of `str_trim()`?**

We can use `str_pad()` to add spaces or other characters. The usage of `str_pad()` is:

`str_pad(string, width, side = c("left", "right", "both"), pad = " ")`

We try to pad `string_no_sapces` back to `string_with_spaces`. Notice that, we need to add two spaces both at the beginning and the end of the string, which means we need to make the width of the final string 4 characters more.

```{r}
# we try to pad string_no_spaces back to string_with_spaces
str_pad(string_no_spaces,
        width = str_length(string_no_spaces) + 4,
        side = c("both"),
        pad = " ")
```

### Question 6

**Write a function that turns (e.g.) a vector `c("a", "b", "c")` into the string `a`, `b`, and `c`. Think carefully about what it should do if given a vector of length 0, 1, or 2.**

Assuming the final string is "a, b, and c", we make the following rules for the function:

- If the length of vector is 0, we return an empty string (""); 
- If the length of vector is 1, we return the string inside the vector (e.g., "a");
- If the length of vector is 2, we follow the same format as the length is 3 or above, which means we return, for example, "a, and b".

```{r}
# function to convert vector into a string
vector_to_string <- function(v) {
  if (length(v) == 0) {
    return("")
  } else if (length(v) == 1) {
    return(v)
  } else {
    # first, convert all elements except the last one into a string
    first_part <- str_c(v[-length(v)], collapse = ", ")
    # second, add the last element with "and"
    whole_string <- str_c(first_part, v[length(v)], sep = ", and ")
    # return the final string
    return(whole_string)
  }
}
```

Let's use `testthat` package to test our function.

```{r}
# create four vectors to test
l0 <- c()
l1 <- c("a")
l2 <- c("a", "b")
l3 <- c ("a", "b", "c")

# create test suite
test_that("function vector_to_string() is wrong", {
  # test case 1: vector length of 0
  expect_equal(vector_to_string(l0), "")
  # test case 2: vector length of 1
  expect_equal(vector_to_string(l1), "a")
  # test case 3: vector length of 2
  expect_equal(vector_to_string(l2), "a, and b")
  # test case 4: vector length of 3
  expect_equal(vector_to_string(l3), "a, b, and c")
})
```

All the above tests are passed.

## Exercises 14.3.1.1

### Question 1

**Explain why each of these strings don't match a \\: "\\", "\\\\", "\\\\\\".**

"\\" is an escape character in both R and regex (writtern inside R). Therefore:

- "\\" is an escape character in R, which leads to an R error (incomplete expression).
- "\\\\" will be treated as one back slash ("\\") in R, which becomes an escape character in regex (writtern inside R), and therefore leads to a regex error.
- Similarly, "\\\\\\" will be treated as a back slash with an escape character in regex (writtern inside R), which also leads to a regex error.

The following is an sucessful example using "\\\\\\\\" to match a "\\".

```{r}
# create a string to test
test_back_slash <- "STAT\\547M"

str_view(test_back_slash, pattern = "\\\\", match = TRUE)
```



### Question 2

**How would you match the sequence "'\\?**

Since both "'" and "\\" needs to be escaped in regex, we need to use "\\'\\\\" to match it.

```{r}
# create a string to test
test_back_slash <- "STAT'\\547M"

# use str_view() for matching
str_view(test_back_slash, pattern = "\\'\\\\", match = TRUE)
```


### Question 3

**What patterns will the regular expression \\..\\..\\.. match? How would you represent it as a string?**

Regex "\\..\\..\\.." can match a string with six characters: a dot follows by any character, follows by another dot and a another character, then end with a dot follows by another character. Here is an example, "a", "b", or "c" can be any other characters.

```{r}
# create a string to test
test_pattern <- "STAT.a.b.c547M"

# use str_view() for matching
str_view(test_pattern, pattern = "\\..\\..\\..", match = TRUE)
```

## Exercises 14.3.2.1

### Question 1

**How would you match the literal string "\$^\$"?**

We need to escape both "\$" and "^" in regex. Therefore, "\\\\\$\\\\^\\\\\$" is a suitable pattern.

```{r}
# create a string to test
test_pattern <- "STAT$^$547M"

# use str_view() for matching
str_view(test_pattern, pattern = "\\$\\^\\$", match = TRUE)
```

### Question 2

**Given the corpus of common words in `stringr::words`, create regular expressions that find all words that fulfilling the following requirements. Since this list is long, you might want to use the `match` argument to `str_view()` to show only the matching or non-matching words.**

**Requirement 1: start with "y".**

```{r}
# find words start with "y"
str_view(stringr::words, pattern = "^y", match = TRUE)
```


**Requirement 2: End with "x".**

```{r}
# find words end with "x"
str_view(stringr::words, pattern = "x$", match = TRUE)
```

**Requirement 3: are exactly three letters long. (Don't cheat by using `str_length()`!).**

```{r}
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))

# find words that are exactly three letters long
str_view(stringr::words[index], pattern = "^.{3}$", match = TRUE)
```

**Requirement 4: have seven letters or more.**

```{r}
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))

# find words that have seven letters or more
str_view(stringr::words[index], pattern = "^.{7,}$", match = TRUE)
```


## Exercises 14.3.3.1

### Question 1

**Create regular expressions to find all words that fulfull the following requirements.**

**Requirement 1: start with a vowel.**

```{r}
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))

# find words that start with a vowel
str_view(stringr::words[index], pattern = "^[aeiou]", match = TRUE)
```

**Requirement 2: that only contain consonants. (Hint: thinking about matching "not"-vowels.)**

We change `match` to `FALSE` in order to show words that does not contains vowels, which fulfulls the requirement.

```{r}
# find words that without a vowel
str_view(stringr::words, pattern = "[aeiou]", match = FALSE)
```

**Requirement 3: end with `ed`, but not with `eed`.**

```{r}
# find words that end with "ed" but not "eed"
str_view(stringr::words, pattern = "[^e]ed$", match = TRUE)
```

**Requirement 4: end with `ing` or `ise`.**

```{r}
# find words that end with "ing" or "ise"
str_view(stringr::words, pattern = "ing$|ise$", match = TRUE)
```

### Question 2

**Empirically verify the rule "i before e except after c".**

To solve this question, it means we need to ensure:

- The number of "ie" and the number of "cei" are high enough.
- The number of "ei" and the number of "cie" are low enough.

Therefore, we try the following to regexes.

```{r}
# subset words with "ie" and "cei"
high_subset <- str_subset(stringr::words, pattern = "[^c]ie|cei")
high_subset %>% 
  knitr::kable(col.names = c("Words with \"ie\" or \"cei\""))

# subset words with "ei" and "cie"
low_subset <- str_subset(stringr::words, pattern = "[^c]ei|cie")
low_subset %>% 
  knitr::kable(col.names = c("Words with \"ei\" or \"cie\""))

# perform a test showing that there are more words in subset 1 than subset 2
test_that("The rule is not correct", {
  expect_more_than(length(high_subset), length(low_subset))
})
```

So the rule is empirically verified.

### Question 3

**Is "q" always followed by a "u"?**

To solve this question, it means we need to ensure there is no match for "q followed by not u".

Therefore, we try the following to regexes.

```{r}
# check if there is "q followed by not u"
str_view(stringr::words, pattern = "q[^u]", match = TRUE)
```

The result is empty, so the statement is true.

### Question 4

**Write a regular expression that matches a word if it's probably written in British English, not American English.**

According to [this reference](https://learningenglish.voanews.com/a/six-difference-between-britsh-and-american-english/3063743.html), there are spelling differences in British English and American English. For example, in American English, "u" is dropped in some words end with "our" (which means only "or" is kept, e.g. "colour" and "color"). We can create a regex and use some examples to show it.

```{r}
# create some words to test
test_words <- c("colour", "color", "honour", "honor", "labor", "labour")

# use a regex to detect American English
str_view(test_words, pattern = ".+or$", match = TRUE)
```

### Question 5

**Create a regular expression that will match telephone numbers as commonly written in your country.**

The telephone numbers in Canada follow the following rule: "+1 (111) 111 1111". Therefore we can use the following regex to detect it.

```{r}
# create some telephone numbers to test
test_telephone_numbers <- c("+1 (778) 069 2357", "+86 139 392 2560", "+852 2309 9667")

# use a regex to detect telephone numbers in Canada
str_view(test_telephone_numbers, pattern = "\\+1 \\([1-9][0-9]{2}\\) [0-9]{3} [0-9]{4}")
```

## Exercises 14.3.4.1

### Question 1

**Describe the equivalents of `?`, `+`, `*` in {m,n} form.**

- `?` is equivalent to {0,1},
- `+` is equivalent to {1,}.
- `*` is equivalent to {0,}.

### Question 2

**Describe in words what these regular expressions match: (read carefully to see if I'm using a regular expression or a string that defines a regular expression.)**

- ^.*$ matches any string.
- "\\\\{.+\\\\}" matches word with at least one character, which is surrounded by a pair of curly brackets, for example "{abc}".
- \\d{4}-\\d{2}-\\d{2} matches a string looks like dddd-dd-dd, where d is digit. For example, "1234-56-78".
- "\\\\\\\\{4}" matches four back slashes.

### Question 3

**Create regular expressions to find all words that fulfill the following requirements.**

**Requirement 1: start with three consonants.**

```{r}
# find words that start with three consonants
str_view(stringr::words, pattern = "^[^aeoiu]{3,}", match = TRUE)
```

**Requirement 2: have three or more vowels in a row.**

```{r}
# find words that have three or more vowels in a row
str_view(stringr::words, pattern = "[aeoiu]{3,}", match = TRUE)
```

**Requirement 3: have two or more vowel-consonant pairs in a row.**

```{r}
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))

# find words that have two or more vowel-consonant pairs in a row
str_view(stringr::words[index], pattern = "([aeoui][^aeoiu]){2,}", match = TRUE)
```

### Question 4

**Solve the beginner regexp crosswords [here](https://regexcrossword.com/challenges/beginner).**

The following images are the results for the crosswords.

![](./crosswords/1.png)
![](./crosswords/2.png)
![](./crosswords/3.png)
![](./crosswords/4.png)
![](./crosswords/5.png)

## Exercises 14.3.5.1

### Question 1

**Describe, in words, what these expressions will match:**

- (.)\\1\\1 matches a character appers three times, for example "aaa".
- "(.)(.)\\\\2\\\\1" matches two characters and their reversal, for example "abba".
- (..)\\1 matches a set of two characters appear two times, for example "abab".
- "(.).\\\\1.\\\\1" matches a string with five characters: the first character appears again at the third and fifth places, while the second and forth places are any two characters. For example, "abaca".
- "(.)(.)(.).*\\\\3\\\\2\\\\1" matches a set of three characters appears at the beginning, then follows by any characters (0 or more), then the reversal of the begining three characters. For example, "abcxxxxxxcba".

### Question 2

**Construct regular expressions to match words that fullfill the following requirements.**

**Requirement 1: start and end with the same character.**

```{r}
# find words that start and end with the same character
str_view(stringr::words, pattern = "^(.).*\\1$", match = TRUE)
```

**Requirement 2: contain a repeated pair of letters (e.g. "church" contains "ch" repeated twice.)**

```{r}
# find words that contain a repeated pair of letters
str_view(stringr::words, pattern = "(..).*\\1", match = TRUE)
```

**Requirement 3: contain one letter repeated in at least three places (e.g. "eleven" contains three "e"s.)**

```{r}
# find words that contain one letter repeated in at least three places
str_view(stringr::words, pattern = "(.).*\\1.*\\1", match = TRUE)
```

## Exercises 14.4.2

### Question 1

**For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple `str_detect()` calls.**

**Find all words that start or end with x.**

```{r}
# single regex
str_subset(stringr::words, pattern = "^x|x$") %>% 
  knitr::kable(col.names = c("Detected Words"))

# multiple str_detect() calls
# find positions start with x
c1 <- str_detect(stringr::words, pattern = "^x")
# find positions end with x
c2 <- str_detect(stringr::words, pattern = "x$")
# find subset that start or end with x
stringr::words %>% 
  `[`(c1 | c2) %>% 
  knitr::kable(col.names = c("Detected Words"))
```


**Find all words that start with a vowel and end with a consonant.**

```{r}
# there are too many possible words, so we randomly select some words to test
index <- runif(20, 1, length(stringr::words))

# print those words out
stringr::words %>% 
  `[`(index) %>% 
  sort() %>% 
  knitr::kable(col.names = c("Selected Words"))


# single regex
str_subset(stringr::words[index], pattern = "^[aeiou].*[^aeiou]$") %>% 
  knitr::kable(col.names = c("Detected Words"))

# multiple str_detect() calls
# find positions start with x
c1 <- str_detect(stringr::words[index], pattern = "^[aeiou]")
# find positions end with x
c2 <- str_detect(stringr::words[index], pattern = "[^aeiou]$")
# find subset that start or end with x
stringr::words %>% 
  `[`(index) %>% 
  `[`(c1 & c2) %>% 
  knitr::kable(col.names = c("Detected Words"))
```

**Are there any words that contain at least one of each different vowel?**

It is not possible to find a single regex to solve this question. However, it is easy to solve using `str_detect()`.

```{r}
# multiple str_detect() calls
# define a function for our task
contain_each_vowel <- function(s) {
  # vowels to check
  vowels <- c("a", "e", "i", "o", "u")
  # original results
  check <- as.logical(seq(from = 1, to = 1, along.with = s))
  # check vowels one by one
  for (vowel in vowels) {
    check <- check & str_detect(s, pattern = vowel)
  }
  # return whether s contain at least one of each different vowel
  return(s[check])
}

# create a test case
test_that("function contain_each_vowel() not works", {
  test_string <- "aberixowu"
  
  expect_equal(test_string, contain_each_vowel(test_string))
})
```

### Question 2

**What word has the highest number of vowels?**

```{r}
# count the number of vowels in words
num_vowels <- str_count(stringr::words, pattern = "[aeiou]")

# find the words with the highest number of vowels
stringr::words %>% 
  `[`(which(num_vowels == max(num_vowels))) %>% 
  knitr::kable(col.names = c("Detected Words"))
```


**What word has the highest proportion of vowels? (Hint: what is the denominator?)**

```{r}
# calcuate the proportion of vowels in words
prop_vowels <- str_count(stringr::words, pattern = "[aeiou]") / str_length(stringr::words)

# find the words with the highest number of vowels
stringr::words %>% 
  `[`(which(prop_vowels == max(prop_vowels))) %>% 
  knitr::kable(col.names = c("Detected Words"))
```

The result is reasonable because word "a" has 100% vowel(s).

## Exercises 14.4.3.1

### Question 1

**In the previous example, you might have noticed that the regular expression matched "flickered", which is not a colour. Modify the regex to fix the problem.**

Let's try to reproduce the example used in [this reference](https://r4ds.had.co.nz/strings.html) first.

```{r}
# create a set of colors
colours <- c("red", "orange", "yellow", "green", "blue", "purple")

# turn color vector into a regex
colour_match <- str_c(colours, collapse = "|")
colour_match

# view sentences with more than 1 match
more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)
```

So in the above matches, the second sentence has a wrong match "flickered". To solve this, we can use metacharacter "\\b" in regex. "\\b" works as a  "word boundary" and performs a "whole words only" search.

```{r}
# add \b to regex
colour_match_with_boundary <- str_c("\\b", colour_match, "\\b")
colour_match_with_boundary

# view sentences with more than 1 match
more <- sentences[str_count(sentences, colour_match_with_boundary) > 1]
str_view_all(more, colour_match_with_boundary)
```

The second sentence is then removed.

### Question 2

**From the Harvard sentences data, extract the following words.**

**The first word from each sentence.**

`str_extract()` tries to extract the first match of a string, and put it into a vector.

```{r}
# there are too many possible words, so we randomly select some sentences to test
index <- runif(20, 1, length(sentences))

# apply str_extract to get the first words
first_words <- str_extract(sentences[index], pattern = "[a-zA-Z]+")

# put sentences and results together
tibble(sentences[index], first_words) %>% 
  knitr::kable(col.names = c("Selected Sentences", "First Word"))
```

**All words ending in `ing`.**

`str_extract_all()` tries to extract all matches from a string, and put them into a vector.

```{r}
# apply str_extract_all to get words ending in "ing"
ing_words <- str_extract_all(sentences, pattern = "\\b[a-zA-Z]+ing\\b", simplify = TRUE)

# fortunately, every sentence only contains one words engding in "ing", we can simple remove all empty element
filter_ing_words <- ing_words[ing_words != ""]

# there are too many words, so we only show some of them
head(tibble(sentences[ing_words != ""], filter_ing_words)) %>% 
 knitr::kable(col.names = c("Selected Sentences", "Detected Words"))
```

**All plurals.**

There are many possible rules for plurals, so we cover all cases by simple regex. We try to apply some rules according to [this reference](https://www.grammarly.com/blog/plural-nouns/):

- All the rules only apply to words more than 3 characters.
- "es" is added after "s", "ss", "sh", "ch", "x", or "z".
- Words end with "sses" or "zzes" are probably plurals.
- Words end with "ves" are probably plurals.
- Words end with "ies" are probably plurals.
- Words end with "oes" are probably plurals.
- If no other rule is applied, an "s" is added to the end.

```{r}
# define pattern
pattern <- "\\b[a-zA-Z]{3,}(ses|sses|shes|ches|xes|zes|sses|zzes|ves|ies|oes|s)\\b"

# use str_detect to first filter sentences without plurals
filter_sentences <- sentences[str_detect(sentences, pattern = pattern)]

# apply str_extract_all to get plurals
plurals <- str_extract_all(filter_sentences, pattern = pattern, simplify = TRUE)

# there are too many words, so we only show some of them
data.frame(filter_sentences, plurals)[25:35,] %>% 
 knitr::kable(col.names = c("Selected Sentences", "Plural 1", "Plural 2", "Plural 3"))
```

We cannot avoid false positives using this method, for example "circus", "across", "this", and "makes".

## Exercises 14.4.4.1

### Question 1

**Find all words that come after a "number" like "one", "two", "three" etc. Pull out both the number and the word.**

We get all strings for numbers from [here](https://stackoverflow.com/questions/18332463/convert-written-number-to-number-in-r).

```{r}
# define numbers
nums = c("zero","one","two","three","four","five","six","seven","eight","nine",
         "ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen",
         "twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety",
         "hundred","thousand","million","billion","trillion")

# define pattern
pattern <- str_c(nums, collapse = "|")
pattern <- str_c("(", pattern, ") ([^ \\.]+)")

# use str_detect to first filter sentences without matches
filter_sentences <- sentences[str_detect(sentences, pattern = pattern)]

# apply str_extract_all to get all matches
number_word <- str_extract_all(filter_sentences, pattern = pattern, simplify = TRUE)

# there are too many words, so we only show some of them
tail(data.frame(filter_sentences, number_word)) %>% 
 knitr::kable(col.names = c("Selected Sentences", "Match 1", "Match 2"))
```

### Question 2

**Find all contractions. Separate out the pieces before and after the apostrophe.**

```{r}
# define pattern
pattern <- "([A-Za-z]+)'([A-Za-z]+)"

# use str_detect to first filter sentences without matches
filter_sentences <- sentences[str_detect(sentences, pattern = pattern)]

# apply str_extract_all to get all matches
contractions <- str_extract_all(filter_sentences, pattern = pattern, simplify = TRUE)

# separate contractions into two pieces
pieces <- str_split(contractions, pattern = "'", simplify = TRUE)

# show results as a table
data.frame(filter_sentences, pieces) %>% 
 knitr::kable(col.names = c("Sentences with Contractions", "Before Apostrophe", "After Apostrophe"))
```

## Exercises 14.4.5.1

### Question 1

**Replace all forward slashes in a string with backslashes.**

```{r}
# create some strings to test
test_strings <- c("STAT/547M", "STST/545A")

# replace forward slashed with backslashes
str_replace(test_strings, pattern = "/", "\\\\")
```

Notice that in R, backslashes will be shown as "\\\\".

### Question 2

**Implement a simple version of `str_to_lower()` using `replace_all()`.**

```{r}
# create some strings to test
test_strings <- c("STAT 547M", "STST 545A")

# let's see the results of str_to_lower()
str_to_lower(test_strings)

# use replace_all() to get the same results
str_replace_all(test_strings, c("A"="a", "B"="b", "C"="c", "D"="d", "E"="e", "F"="f", "G"="g", "H"="h", "I"="i", "J"="j", "K"="k", "L"="l", "M"="m", "N"="n", "O"="o", "P"="p", "Q"="q", "R"="r", "S"="s", "T"="t", "U"="u", "V"="v", "W"="w", "X"="x", "Y"="y", "Z"="z"))
```

### Question 3

**Switch the first and last letters in words.**

We use `str_replace()` to switch the letters. We split a word into three groups, the first letter, the middle part, and the third letts, then switch the other of the groups.

```{r}
# switch the first and last letters in words
switch <- str_replace(stringr::words, pattern = "(^[a-zA-Z])([a-zA-Z]*)([a-zA-Z]$)", replacement = "\\3\\2\\1")

# show some of the words
head(switch) %>% 
  knitr::kable(col.names = "Example Words")
```

**Which of those strings are still words?**

```{r}
# find strings that are still words using intersect(), and show part of them
head(intersect(stringr::words, switch), 10) %>% 
  knitr::kable(col.names = "Still Words")
```

## Exercises 14.4.6.1

### Question 1

**Split up a string like "apples, pears, and bananas" into individual components.**

We use `boundary(word)` to control `str_split()`, so it can split the strings based on words.

```{r}
# create string to test
test_string <- c("apples, pears, and bananas")

# use str_split() with boundary(word)
str_split(test_string, boundary("word")) %>% 
  `[[`(1) %>% 
  knitr::kable(col.names = c("Component"))
```

### Question 2

**Why is it better to split up by `boundary("word")` than " "?**

Let's try to use " " to split.

```{r}
# create string to test
test_string <- c("apples, pears, and bananas")

# use str_split() with " "
str_split(test_string, " ") %>% 
  `[[`(1) %>% 
  knitr::kable(col.names = c("Component with Unnessasary Characters"))
```

As shown in the results, `boundary("word")` can make sure only words are selected out, instead of having punctuations and extra whitespaces as using " ".

### Question 3

**What does splitting with an empty string ("") do? Experiment, and then read the documentation.**

```{r}
# create string to test
test_string <- c("apples, pears, and bananas")

# use str_split() with " "
str_split(test_string, "") %>% 
  `[[`(1) %>% 
  knitr::kable(col.names = c("Results using \"\""))
```

Based on the above results and the documentation ("An empty pattern, '', is equivalent to `boundary('character')`'"), an empty string tries to split a string into single characters.

## Exercises 14.5.1

### Question 1

**How would you find all strings containing `\` with `regex()` vs. with `fixed()`?**

Using regex, we need to add escape character for both R and regex, which may lead to a lot of backslashes. If `fixed()` is used, we only need to add escape character for regex, which is more intuitive.

```{r}
# create string to test
test_string <- c("STAT\\547M")

# using regex to find \
str_view(test_string, pattern = "\\\\")

# using fixed() to find \
str_view(test_string, pattern = fixed("\\"))
```


### Question 2

**What are the five most common words in `sentences`?**

We first try to get all words in `sentences` using `str_extract_all()` with `boundary("word")`. Then we can convert the results into a tibble and use techniques discribes in STAT 545A to tidy up the data and find the most common words.

```{r}
word_list <- sentences %>% 
  # extract all words from sentences
  str_extract_all(boundary("word"), simplify = TRUE) %>% 
  # change to lower case for further analysis
  str_to_lower()

# convert results to tibble
tibble(words = word_list) %>% 
  # count by words
  count(words, sort = TRUE) %>% 
  # the first row is the total count, so we need to remove it to get the top five
  slice(2:6) %>% 
  # show it in table
  knitr::kable(col.names = c("Top 5 Words", "Count"))
```


## Exercises 14.7.1

### Question 1

**Find the stringi functions that fullfill the following requirements.**

**Requirement 1: count the number of words.**

We can use `stri_count_words()` for this requirement.

```{r}
# create string to test
test_string <- "This sentence has five words."

# create a test case to test stri_count_words()
test_that("The number of words is not correct", {
  expect_equal(stri_count_words(test_string), 5)
})
```


**Requirement 2: find duplicated strings.**

We can use `stri_duplicated()` or `stri_duplicated_any()` for this requirement:

- `stri_duplicated()` determines which strings in a character vector are duplicates of other elements.
- `stri_duplicated_any()` determines if there are any duplicated strings in a character vector.

We write a function using these two functions, so it can output duplicated strings if they exist.

```{r}
# write a function to output duplicated strings if they exist
output_duplicated <- function(v) {
  if (any(stri_duplicated(v))) {
    return(v[stri_duplicated_any(v)])
  } else {
    return(NA)
  }
}

# create two vectors to test
vector_duplicated <- c("unique", "duplicated", "duplicated")
vector_unique <- c("all", "are", "unique")

# crate a test suite to test our function
test_that("output_duplicated() is not correct", {
  expect_equal(output_duplicated(vector_duplicated), "duplicated")
  expect_equal(output_duplicated(vector_unique), NA)
})
```

**Requirement 3: generate random text.**

We can use the following two functions for this requirement:

- `stri_rand_strings()`: generate a (pseudo) random strings of desired lengths. The usage of it is as followed, which means that we can use `n` to control how many texts we want to generate, use `length` to control length, and use `pattern` to even decide what we want to generate.

`stri_rand_strings(n, length, pattern = "[A-Za-z0-9]")`

- `stri_rand_lipsum()`: generate a (pseudo) random *lorem ipsum* text consisting of a given number of text paragraphs.

```{r}
# use stri_rand_strings() to generate random text (for example, password)
stri_rand_strings(n = 5, length = 16, pattern = "[A-Za-z0-9!@$%\\^\\&*]") %>% 
  knitr::kable(col.names = c("Random Text (Password)"))

# use stri_rand_ipsum() to generate random text
stri_rand_lipsum(1)
```

### Question 2

**How do you control the language that stri_sort() uses for sorting?**

According to the document shown using `?stri_sort`, we can use argument `opts_collator` to control the language uses for sorting. For example, we can try to sort french words.

```{r}
# create vector to test
french_words <- c("Bonjour", "Amour", "Bonheur", "Chat", "Chien")

# use stri_sort() to sort french words, especially for Canadian French
stri_sort(french_words, french = TRUE)
```

# Task 2: Work with the `singer` data

## Task 2.1

**Use `purrr` to map latitude and longitude into human readable information on the band's origin places.**


Let's first have a preview of `single_locations` dataframe, in order to know why it is "dirty".
```{r}
# show previews of single_locations
head(singer_locations) %>% 
  # select columns we care about
  select(track_id, latitude, longitude, name, city) %>% 
  knitr::kable(col.names = c("Track ID", "Latitude", "Longitude", "Name", "City"))

tail(singer_locations) %>% 
  # select columns we care about
  select(track_id, latitude, longitude, name, city) %>% 
  knitr::kable(col.names = c("Track ID", "Latitude", "Longitude", "Name", "City"))
```

So the dataframe is "dirty" because it contains `NA` values. Therefore, the first thing we need to do is to filter out rows with `NA` latitude or longitude.

```{r}
# filter out latitude and longitude with NA
singer_locations_no_na <- singer_locations %>% 
  filter(!is.na(latitude) | !is.na(longitude))

# show previews of filtered dataframe
head(singer_locations_no_na) %>% 
  # select columns we care about
  select(track_id, latitude, longitude, name, city) %>% 
  knitr::kable(col.names = c("Track ID", "Latitude", "Longitude", "Name", "City"))

tail(singer_locations_no_na) %>% 
  # select columns we care about
  select(track_id, latitude, longitude, name, city) %>% 
  knitr::kable(col.names = c("Track ID", "Latitude", "Longitude", "Name", "City"))
```

In the next step, we use `map2()` (since we need to input both latitude and longitude) of `purrr` and `revgeocode()` of `ggmap` to get the cities. Her we use `revgeocode()` as a **formula** instead of a **function** inside `map2()`. According to [this reference](https://www.rdocumentation.org/packages/purrr/versions/0.2.5/topics/map2), we need to add "~" before the function name, and use ".x" and ".y" to represent those two arguments.

In addtion, since there are more than 4,000 rows in `singer_locations_no_na`, and it requires billing on Google Clouds Services, we only use the first 30 rows as an example. However, this solution can be easily extended to handle the whole dataframe.

```{r, message = FALSE}
# trim singer_locations_no_na for the top 100 rows
trim_locations <- singer_locations_no_na %>% 
  slice(1:30)

# use ggmap to get locations
ggmap_locations <- map2_chr(trim_locations$longitude, trim_locations$latitude, ~ revgeocode(as.numeric(c(.x, .y))))
```

Here we apply `map2_chr()` to make the results as a vector of strings instead of a list to get rid of unnecessary information.

```{r}
# show the final results
cbind(trim_locations$city, ggmap_locations) %>% 
  knitr::kable(col.names = c("City in `singer_locations`", "City Obtained by `ggmap`"))
```

## Task 2.2

**Try to check wether the place in `city` corresponds to the information you retrieved.**

Having a closer look at the above table, there is another point that make `city` dirty: the way to name a city are not the same accoss the column, for example, "UK - England - London" is a weired expression.

However, we can perform some preprocessing on the data to finish this task:

- We first extract words from every string, and convert them into lower case for further processing.
- Based on some knowledge on the states of America, we replace all full state names into their abbreviations.

In the end, we try to find the intersection of the original `city` and the ones obtained from `ggmap`. If there is at least one match for a row, then we get the right result.

```{r}
# create pattern for replacement
patterns <- c("new york" = "ny", "pennsylvania" = "pa", "california" = "ca", "washington" = "wa", "louisiana" = "la")

## preprocessing
ori_words <- trim_locations$city %>%
  # convert to lower case
  str_to_lower() %>% 
  # split into words
  str_split(pattern = boundary("word")) %>%
  # replace state names
  map(str_replace_all, patterns)

ggmap_words <- ggmap_locations %>% 
  # convert to lower case
  str_to_lower() %>% 
  # split into words
  str_split(pattern = boundary("word")) %>%
  # replace state names
  map(str_replace_all, patterns)

## find intersection and check if there are at least one match
correct <- map2(ori_words, ggmap_words, ~intersect(.x, .y)) %>% 
  map(function(l) {
    return(length(l) >= 1)
  })

# show results
cbind(trim_locations$city, ggmap_locations, correct) %>% 
  knitr::kable(col.names = c("City in `singer_locations`", "City Obtained by `ggmap`", "Correct?"))
```

So there is only one incorrect result at line 15.

```{r}
# print incorrect results
cbind(trim_locations$city, ggmap_locations, correct) %>% 
  # convert to tibble
  as_tibble() %>% 
  # filter to have incorrect results
  filter(correct == FALSE) %>% 
  # select out column correct
  select(-correct) %>% 
  # show table
  knitr::kable(caption = "Incorrect Result", col.names = c("City in `singer_locations`", "City Obtained by `ggmap`"))
```


## Task 2.3

**If you still have time, you can go visual.**

```{r}
# use leaflet to plot information
singer_locations_no_na %>% 
  leaflet() %>% 
  addTiles() %>% 
  addCircles(
    lat = singer_locations_no_na$latitude,
    lng = singer_locations_no_na$longitude,
    # here the popup contains city, title, artist name and year
    popup = str_c(singer_locations_no_na$city, ": ", singer_locations_no_na$title, " by ", singer_locations_no_na$artist_name, " in ", singer_locations_no_na$year)
  ) %>% 
  addProviderTiles(providers$OpenStreetMap)
```

